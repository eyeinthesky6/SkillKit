const fs = require('fs-extra');
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);

/**
 * Execute Fix Plan Skill
 * Executes the fix plan generated by analyze-errors
 */
module.exports = async (input, context) => {
  const {
    planFile = './fix-plan.json',
    dryRun = false,
    autoFix = true,
    stopOnError = false
  } = input;

  const workingDir = context.workingDir || process.cwd();
  const planPath = path.resolve(workingDir, planFile);

  // Load fix plan
  if (!await fs.pathExists(planPath)) {
    throw new Error(`Fix plan not found: ${planPath}. Run analyze-errors first.`);
  }

  const fixPlan = await fs.readJSON(planPath);

  if (!fixPlan.plan || !fixPlan.plan.steps) {
    throw new Error('Invalid fix plan format');
  }

  const results = [];
  let successful = 0;
  let failed = 0;
  let skipped = 0;

  // Execute each step
  for (const step of fixPlan.plan.steps) {
    if (stopOnError && failed > 0) {
      // Skip remaining steps if stopOnError is true and we've failed
      results.push({
        step: step.step,
        action: step.action,
        command: step.command,
        status: 'skipped',
        output: '',
        error: 'Skipped due to previous failure'
      });
      skipped++;
      continue;
    }

    if (dryRun) {
      // Dry run - just show what would be executed
      results.push({
        step: step.step,
        action: step.action,
        command: step.command,
        status: 'skipped',
        output: `[DRY RUN] Would execute: ${step.command}`,
        duration: 0
      });
      skipped++;
      continue;
    }

    // Execute the step
    const result = await executeStep(step, workingDir, autoFix);
    results.push(result);

    if (result.status === 'success') {
      successful++;
    } else {
      failed++;
    }
  }

  // Calculate remaining errors (run final diagnostic)
  let remainingErrors = 0;
  if (!dryRun && failed === 0) {
    try {
      const diagnostic = await execAsync('tsk diagnose --json', { cwd: workingDir });
      const diagData = JSON.parse(diagnostic.stdout);
      remainingErrors = diagData.totalErrors || 0;
    } catch {
      // Couldn't get diagnostic, estimate based on failed steps
      remainingErrors = failed;
    }
  }

  // Save execution log
  const logFile = path.join(workingDir, 'fix-execution-log.json');
  await fs.writeJSON(logFile, {
    timestamp: new Date().toISOString(),
    dryRun,
    results,
    summary: {
      totalSteps: fixPlan.plan.steps.length,
      successful,
      failed,
      skipped,
      remainingErrors
    }
  }, { spaces: 2 });

  return {
    executed: !dryRun,
    results,
    summary: {
      totalSteps: fixPlan.plan.steps.length,
      successful,
      failed,
      skipped,
      remainingErrors
    },
    logFile: path.relative(workingDir, logFile)
  };
};

/**
 * Execute a single step
 */
async function executeStep(step, workingDir, autoFix) {
  const startTime = Date.now();

  try {
    let command = step.command;

    // Handle special commands
    if (command === 'manual-investigation') {
      return {
        step: step.step,
        action: step.action,
        command,
        status: 'skipped',
        output: 'Manual investigation required - cannot automate',
        duration: Date.now() - startTime
      };
    }

    if (command === 'check build configuration') {
      return {
        step: step.step,
        action: step.action,
        command,
        status: 'skipped',
        output: 'Manual configuration check required',
        duration: Date.now() - startTime
      };
    }

    // Add --fix flag for linters if autoFix is enabled
    if (autoFix && command.includes('eslint') && !command.includes('--fix')) {
      command += ' --fix';
    }

    // Execute command
    const { stdout, stderr } = await execAsync(command, {
      cwd: workingDir,
      timeout: 60000 // 1 minute timeout
    });

    return {
      step: step.step,
      action: step.action,
      command,
      status: 'success',
      output: stdout || stderr || 'Command completed successfully',
      duration: Date.now() - startTime
    };

  } catch (error) {
    return {
      step: step.step,
      action: step.action,
      command: step.command,
      status: 'failed',
      output: error.stdout || '',
      error: error.stderr || error.message,
      duration: Date.now() - startTime
    };
  }
}

